import * as needle from "needle";
import * as cheerio from "cheerio";

export class RecipeBuilder {

    private static keys: string[] = [
        "recipeIngredient",
        "recipeInstructions",
        "headline",
        "thumbnailUrl",
        "description",
        "cookTime",
        "prepTime",
        "name"
    ];

    private static excluding: string[] = [
        "review", "author"
    ];

    static async build(url: string, formatted: boolean): Promise<any> {
        let html = await needle.default(
            "get",
            url
        )
        const $ = cheerio.load(html.body)
        const $selected = $('[type="application/ld+json"]').text();
        try {
            if ($selected.length == 0 || $selected === undefined) {
                return null
            }
            const json =  JSON.parse($selected)
            return formatted ? RecipeBuilder.search(json, url) : $selected
        } catch(error) {
            console.log(`selected: ${$selected}`)
            console.log(`url: ${url}`)
            console.log(`error: ${error}`)
            return
        }
    }

    private static search(json: any, url: string): any {
        //console.log(json)
        let queue = [json];

        let rtrnDict: Map<string, any> = new Map();
        while(queue.length > 0 && rtrnDict.size < RecipeBuilder.keys.length) {
            const cur = queue.shift();

            if (Array.isArray(cur)) {
                queue = queue.concat(cur)
            } else if(typeof cur === 'object') {
                
                for (let i=0;i<RecipeBuilder.keys.length;i++) {
                    const key = RecipeBuilder.keys[i]
                    const val = cur[key]
                    if(rtrnDict.get(key) === undefined && val) {
                        rtrnDict.set(key, val)
                    }
                }

                for (const [key, value] of Object.entries(cur)) {
                    if (!RecipeBuilder.excluding.includes(key)) {
                        queue.push(value)
                    }
                }
            }
        }

        // check the instructions arr for common parsing switch ups
        const instructions = (<Array<any>>rtrnDict.get("recipeInstructions"))

        if(instructions[0]['itemListElement']) {
            let newInstructions: Array<any> = []
            const mapped = instructions.map((instruction) => {
                return instruction["itemListElement"]
            })
            for (let i = 0; i<instructions.length;i++) {
                let internalInstructions: Array<any> = instructions[i]["itemListElement"]
                for (let j = 0; j < internalInstructions.length; j++) {
                    newInstructions.push(internalInstructions[j])
                }
            }
            rtrnDict.set("recipeInstructions", newInstructions)
        }
        rtrnDict.set("recipeUrl", url)

        return JSON.stringify(Object.fromEntries(rtrnDict))
    }
}