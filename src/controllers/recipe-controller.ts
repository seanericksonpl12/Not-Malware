import * as express from "express"
import { RSRequest, RSRequestParams } from "../models/rs/rs-request";
import { Controller } from "./controller";
import { HttpError } from "../models/http-error";
import { APP_ERROR_MESSAGE } from "../constants/constants";
import { RecipeBuilder } from "../utility/RecipeBuilder";
import { RSImageRequest, RSImageRequestParams } from "../models/rs/rs-image-request";
import { AppConfig } from "../models/rs/appconfig";

export class RecipeController extends Controller {

    constructor() {
        super()
        this.router.get("/pageSearch", this.pageSearch);
        this.router.get("/pageStream", this.pageStream);
        // this.router.get("/testBuild", this.testSearch);
        this.router.get("/getRecipeImg", this.getRecipeImg);
        this.router.get("/appConfig", this.appConfig);
    }

    async pageSearch(req: express.Request, res: express.Response, next: express.NextFunction) {
        try {
            const index = req.query["index"] as string || "0"
            const search = req.query["search"] as string
            const request = new RSRequest(new RSRequestParams(search, index))
            super.get(request, next, (status, body) => {
                const error = body["error"]
                if(error) {
                    const status = error["code"] || 500
                    const errorMessage = error["status"] || APP_ERROR_MESSAGE.serverErrorType
                    const message = error["message"] || APP_ERROR_MESSAGE.serverError
                    const httpError = new HttpError(status, errorMessage, message, error)
                    console.log("eeeeeerrror")
                    next(httpError)
                    return
                } else {
                    res.status(status).json(body)
                }
            })
        } catch(error) {
            console.log("error!");
            next(error);
        }
    }

    async getRecipeImg(req: express.Request, res: express.Response, next: express.NextFunction) {
        try {
            const title = req.query["title"] as string
            const request = new RSImageRequest(new RSImageRequestParams(title))
            if (title === undefined || title === null || title.length == 0) {
                const status = 400
                const errorMessage =  APP_ERROR_MESSAGE.badParameter
                const message = APP_ERROR_MESSAGE.badParameter
                const httpError = new HttpError(status, errorMessage, message)
                next(httpError)
                return
            }
            let response = await super.getAsync(request, next)
            const status = response.statusCode || 400
            const error = response.body["error"]
                if(error) {
                    const status = error["code"] || 500
                    const errorMessage = error["status"] || APP_ERROR_MESSAGE.serverErrorType
                    const message = error["message"] || APP_ERROR_MESSAGE.serverError
                    const httpError = new HttpError(status, errorMessage, message, error)
                    next(httpError)
                    return
                } else {
                    res.status(status).json(response.body)
                }
        } catch(error) {
            next(error)
        }
    }

    // //TEST
    // async testSearch(req: express.Request, res: express.Response, next: express.NextFunction) {
    //     let recipe = await RecipeBuilder.build("https://feelgoodfoodie.net/recipe/ground-beef-tacos-napa-cabbage-guacamole/", true)
    //     res.status(200).json(recipe)
    // }

    async pageStream(req: express.Request, res: express.Response, next: express.NextFunction) {
        try {
            const startMain = Date.now();
            console.log("hit!")
            req.on("close", () => {
                // request closed
                console.log('client ended connection')
                res.end();
                res.socket?.end();
            });

            res.writeHead(200, {
                'Content-Type': "text/event-stream",
                'Cache-Control': "no-cache",
                'Connection': "keep-alive"
            });

            const index = req.query["index"] as string || "0";
            const search = req.query["search"] as string;
            const formatted = req.query["formatted"] as string === 'true'
            if (search == '') {
                res.end()
                return
            }
            let currentIndex = Number(index);
            let averageBuildTime = 0.0;
            let numBuilds = 0.0;
            let maxBuildTime = 0.0;
            let minBuildTime = Number.MAX_SAFE_INTEGER;
            while(currentIndex < 10) {

                const request = new RSRequest(new RSRequestParams(search, `${currentIndex}`));
                const response = await super.getAsync(request, next);
                
                for (let i = 0; i < response.body["items"].length; i++) {
                    if(res.closed || res.socket?.closed) {
                        return;
                    }

                    try {
                        const urlToBuild = response.body["items"][i]["link"];
                        let startBuild = Date.now();
                        const recipe = await RecipeBuilder.build(urlToBuild, formatted);
                        let endBuild = Date.now();
                        let buildTime = endBuild - startBuild;
                        if (minBuildTime > buildTime) { 
                            minBuildTime = buildTime;
                        }
                        if (maxBuildTime < buildTime) {
                            maxBuildTime = buildTime;
                        }
                        averageBuildTime += buildTime;
                        numBuilds++;
                        if(recipe === undefined || recipe === null || recipe == "") {
                            continue;
                        }
                        if(recipe.length != 0) {
                            res.write(`${recipe}\n`);
                        }
                    } catch(error) {
                        console.log(`error: ${error}`);
                        continue;
                    }
                }
                currentIndex += 10;
            }
            averageBuildTime /= numBuilds
            console.log("closing stream");
            const endMain  = Date.now();
            console.log(`Execution time: ${endMain - startMain} ms`);
            console.log(`Build Execution Time:\navg: ${averageBuildTime} ms\nmax: ${maxBuildTime} ms\nmin: ${minBuildTime} ms`);
            res.end();
        } catch(error) {
            next(error);
        }
    }

    appConfig(req: express.Request, res: express.Response, next: express.NextFunction) {
        console.log(`env value: ${process.env.RS_SEARCH_ENABLED}`)
        const appConfig: AppConfig = {
            featureFlags: {
                searchEnabled: process.env.RS_SEARCH_ENABLED === 'true'
            }
        }
        console.log(`Appconfig: ${JSON.stringify(appConfig)}`)
        setTimeout(() => 
            {
                res.status(200).json(appConfig)
            },
            5000);
        
    }
}